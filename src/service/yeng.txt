import path from "node:path";
import { fileURLToPath } from "node:url";
import { config as dotenvConfig } from "dotenv";
import { login } from "../auth/billz.auth.js";
import { isOlderThanDays, writeJSON, readJSON } from "../utils/helper.js";
import axios from "axios";

dotenvConfig();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const BILLZ_URL = (
  process.env.BILLZ_URL || "https://api-admin.billz.ai/v2"
).replace(/\/$/, "");
// Resolve to project src directory (one level up from service/)
const SRC_DIR = path.resolve(__dirname, "..");
const AUTH_STATE_FILE = path.join(SRC_DIR, "auth", "billz.auth.state.json");

function isValidJWT(token) {
  if (!token || typeof token !== 'string') {
    return false;
  }
  const parts = token.split('.');
  return parts.length === 3;
}

export async function ensureBillzLoginIfStale() {
  try {
    const state = (await readJSON(AUTH_STATE_FILE)) || {};
    const lastLoginAt = state.lastLoginAt;
    const existingToken = state.auth?.data?.access_token;
    
    // Validate existing token format
    if (existingToken && !isValidJWT(existingToken)) {
      console.error("Stored token is invalid. Forcing new login.");
      // Force new login by setting lastLoginAt to old date
      state.lastLoginAt = null;
    }
    
    if (isOlderThanDays(lastLoginAt, 5) || !existingToken) {
      console.log("Performing new Billz login...");
      
      // Check if secret key exists
      if (!process.env.BILLZ_API_SECRET_KEY) {
        throw new Error("BILLZ_API_SECRET_KEY environment variable is not set");
      }
      
      try {
        const auth = await login();
        
        // Validate the received token
        const newToken = auth.data?.access_token;
        if (!newToken) {
          throw new Error("No access_token in login response");
        }
        if (!isValidJWT(newToken)) {
          throw new Error(`Received invalid JWT token: ${newToken.substring(0, 20)}...`);
        }
        
        const nextState = {
          lastLoginAt: new Date().toISOString(),
          auth,
        };
        await writeJSON(AUTH_STATE_FILE, nextState);
        console.log("Billz login performed and state updated successfully.");
        
        return newToken;
      } catch (err) {
        console.error("Billz login attempt failed:", err.message || err);
        // Log additional debug info
        console.error("Auth URL:", process.env.BILLZ_AUTH_URL || 'https://api-admin.billz.ai/v1/auth');
        console.error("Secret key present:", !!process.env.BILLZ_API_SECRET_KEY);
        console.error("Secret key length:", process.env.BILLZ_API_SECRET_KEY?.length);
        throw err; // Re-throw to prevent app from continuing with invalid auth
      }
    } else {
      console.log("Billz auth is fresh; using existing token.");
      // One final validation before returning
      if (!isValidJWT(existingToken)) {
        throw new Error("Existing token failed validation");
      }
      return existingToken;
    }
  } catch (err) {
    console.error("Fatal error in ensureBillzLoginIfStale:", err);
    throw err;
  }
}

export async function getProducts(props) {
  if (!props.token) {
    throw new Error("Token is required for getProducts");
  }
  
  if (!isValidJWT(props.token)) {
    throw new Error("Invalid token format provided to getProducts");
  }
  
  const LIMIT = 10000;
  let allProducts = [];
  let offset = 0;

  try {
    // First request to get total count
    const initialRequest = await axios.get(`${BILLZ_URL}/products`, {
      headers: {
        Authorization: `Bearer ${props.token}`,
        "Content-Type": "application/json",
      },
      params: {
        limit: LIMIT,
        offset: 0
      }
    });

    const totalCount = initialRequest.data.count;
    console.log("Total products count:", totalCount);
    allProducts.push(...initialRequest.data.products);

    // Calculate remaining requests
    const remainingPages = Math.ceil((totalCount - LIMIT) / LIMIT);

    // Fetch remaining pages
    for (let page = 1; page <= remainingPages; page++) {
      offset = page * LIMIT;
      
      const response = await axios.get(`${BILLZ_URL}/products`, {
        headers: {
          Authorization: `Bearer ${props.token}`,
          "Content-Type": "application/json",
        },
        params: {
          limit: LIMIT,
          offset: offset
        }
      });

      allProducts.push(...response.data.products);
      console.log(`Fetched page ${page + 1}, total products so far: ${allProducts.length}`);
    }

    console.log(`Total products fetched: ${allProducts.length}`);
    return allProducts;
  } catch (err) {
    if (err.response?.status === 401) {
      console.error("Authentication failed. Token may be expired or invalid.");
      // Try to delete the auth state file to force re-login on next attempt
      try {
        await writeJSON(AUTH_STATE_FILE, {});
        console.log("Cleared auth state file. Please restart the service.");
      } catch (writeErr) {
        console.error("Failed to clear auth state:", writeErr);
      }
    }
    throw err;
  }
}

export async function deleteDuplicates() {
  try {
    const token = await ensureBillzLoginIfStale();
    const products = await getProducts({ token });
    const barcodeMap = new Map();

    // Barcode bo'yicha guruhlash
    for (const prod of products) {
      if (prod.barcode) {
        if (!barcodeMap.has(prod.barcode)) {
          barcodeMap.set(prod.barcode, []);
        }
        barcodeMap.get(prod.barcode).push(prod);
      } else {
        // Barcode yo'q bo'lsa unique
        barcodeMap.set(Symbol(), [prod]);
      }
    }

    const uniqueProducts = [];
    const duplicates = [];

    for (const group of barcodeMap.values()) {
      if (group.length === 1) {
        uniqueProducts.push(group[0]);
        continue;
      }
      // Eng katta active_measurement_value ni topamiz
      let maxIdx = 0;
      let maxValue = -Infinity;
      for (let i = 0; i < group.length; i++) {
        const prod = group[i];
        let val = 0;
        if (Array.isArray(prod.shop_measurement_values)) {
          val = Math.max(
            ...prod.shop_measurement_values.map(smv => smv.active_measurement_value || 0)
          );
        }
        if (val > maxValue) {
          maxValue = val;
          maxIdx = i;
        }
      }
      uniqueProducts.push(group[maxIdx]);
      // Qolganlarini duplicates ga
      group.forEach((prod, idx) => {
        if (idx !== maxIdx) duplicates.push(prod);
      });
    }

    console.log(`Unique products: ${uniqueProducts.length}, duplicates: ${duplicates.length}`);
    return { uniqueProducts, duplicates };
  } catch (err) {
    console.error("Error in deleteDuplicates:", err);
    throw err;
  }
}